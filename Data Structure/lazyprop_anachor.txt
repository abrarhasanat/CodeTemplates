#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

#define  ll  long long
#define  pii pair<int,int>
#define  pll pair<ll , ll>
#define  debug cout << "this far" << endl;
#define  For(i, n) for(int i = 0; i < (n); ++i)
#define  mod 1000000007LL
#define  lsb(x) ((x) & (-x))
#define  PI acos(-1)
#define  line cout << endl;
#define  getbit(n, i) (((n) & (1LL << (i))) != 0)
#define  resetbit(n, i) ((n) & (~(1LL << (i))))
#define  setbit(n, i) ((n) | (1LL << (i)))
#define  togglebit(n, i) ((n) ^ (1LL << (i)))
#define  ordered_set tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update>
//using namespace __gnu_pbds;
using namespace std;
const ll N = 2e5 + 10;
ll lazy[N*4], arr[N];
pll tree[N*4] ;
pll combine(pll a , pll b) {
    if(a.first == b.first) {
        return (a.second > b.second) ?  a : b ;
    }
    return  a.first < b.first ? a : b ;
}
void prop(ll at , ll left ,ll right) {
    if(!lazy[at]) return;
    tree[at].first += lazy[at] ;
    if(left != right) {
        lazy[at*2] += lazy[at] ;
        lazy[at*2 + 1] += lazy[at] ;
    }
    lazy[at] = 0 ;
}
void build(ll at ,ll left ,ll right) {
    if(left == right) {
        tree[at].first = arr[left]  ;
        tree[at].second = left;
        return;
    }
    build(at*2 , left , (left + right)/2) ;
    build(at*2 + 1 , (left + right)/2 + 1 , right) ;
    tree[at] = combine(tree[at*2],tree[at*2 + 1] ) ;
    lazy[at] =  0 ;
}
void update (ll at ,ll left ,ll right , ll start , ll end ,ll val) {
    prop(at, left , right) ;
    if(right < start || left > end) return;
    if(left >= start && right <= end) {
        lazy[at] += val ;
        prop(at ,left , right) ;
        return;
    }
    update(at*2 , left , (left + right)/2 , start ,end , val) ;
    update(at*2 + 1 ,(left + right) /2  + 1 , right   , start ,end  ,val) ;
    tree[at] = combine(tree[at*2] , tree[at*2 + 1] ) ;
}
pll query (ll at, ll left ,ll right ,ll start ,ll end) {
    prop(at ,left , right) ;
    if(right < start || left > end) return {2e18 , -1} ;
    if(left >= start && right <= end) {
        return tree[at] ;
    }
    return combine(query(at*2 ,left , (left + right)/2 , start ,end) , query(at*2 + 1 , (left + right)/2 + 1 , right ,start , end)) ;
}

int  main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    ll n; cin >> n;
    for(ll i= 1;  i <=n ;++i) cin >> arr[i] ;
    build(1, 1, n) ;
    vector<ll>ans(n  + 1) ;
    for(ll i = 1 ; i <= n ; ++i) {
        pll val = query (1, 1, n,  1 ,n) ;
        ans[val.second] = i;
        update(1 ,1 ,n, val.second + 1 , n , -i ) ;
        update(1, 1 , n ,val.second , val.second , 2e18) ;
    }
    for(ll i =1 ;  i <= n ;++i) cout << ans[i] << " " ;

}